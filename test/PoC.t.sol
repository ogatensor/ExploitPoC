// SPDX-License-Identifier: MIT 
pragma solidity ^0.8.0;

import "forge-std/Test.sol"; // Importing the Test library from forge-std
import "../src/Market.sol"; // Importing the Market contract
import "../src/MockOracle.sol"; // Importing the MockOracle contract

contract VulnerabilityTest is Test { // Defining a contract for testing vulnerabilities
    Market public market; // Declaring a public variable of type Market

function setUp() public { // Function to set up the test environment
    // Mock parameters for Market constructor
    address _gov = address(0x1); // Mock governance address
    address _lender = address(0x2); // Mock lender address
    address _pauseGuardian = address(0x3); // Mock pause guardian address
    address _escrowImplementation = address(0x4); // Mock escrow implementation address
    IDolaBorrowingRights _dbr = IDolaBorrowingRights(address(0x5)); // Mock DolaBorrowingRights interface
    IERC20 _collateral = IERC20(address(0x6)); // Mock ERC20 token for collateral
    IOracle _oracle = IOracle(new MockOracle()); // Creating a new MockOracle and casting it to IOracle
    uint _collateralFactorBps = 9000; // Mock collateral factor in basis points
    uint _replenishmentIncentiveBps = 100; // Mock replenishment incentive in basis points
    uint _liquidationIncentiveBps = 150; // Mock liquidation incentive in basis points
    bool _callOnDepositCallback = true; // Mock flag for calling on deposit callback

    market = new Market( // Instantiating a new Market contract with the mock parameters
        _gov, 
        _lender, 
        _pauseGuardian, 
        _escrowImplementation, 
        _dbr, 
        _collateral, 
        _oracle, 
        _collateralFactorBps, 
        _replenishmentIncentiveBps, 
        _liquidationIncentiveBps, 
        _callOnDepositCallback
    );
    // Set up a mock oracle with manipulated price
    IOracle mockOracle = IOracle(new MockOracle()); // Creating a new MockOracle and casting it to IOracle
    market.setOracle(mockOracle); // Setting the oracle in the market contract to the new MockOracle
    // Manipulate the price to be lower than expected
    MockOracle(address(mockOracle)).setPrice(address(market.collateral()), 0.5 ether); // Setting the price of collateral to half the expected price

    // Set a high collateral factor to amplify the effect of price manipulation
    market.setCollateralFactorBps(9000); // Setting the collateral factor to 90%

    // Set up user debts and collateral balances
    address user = address(1); // Mock user address
    IEscrow escrow = IEscrow(market.predictEscrow(user)); // Predicting and casting the escrow address for the user
    payable(address(escrow)).transfer(10 ether); // User deposits 10 ether as collateral using a payable transfer
    market.setDebt(user, 5 ether); // Setting the user's debt to 5 ether

    // Simulate initial borrowing for test setup
    market.borrowInternal(user, user, 5 ether); // Simulate borrowing 5 ether
}

function testManipulatedMinimumCollateral() public { // Function to test manipulated minimum collateral
    address user = address(1); // Mock user address
    uint withdrawalLimit = market.getWithdrawalLimitInternal(user); // Calculating the withdrawal limit for the user
    // Check if the withdrawal limit is higher than it should be due to manipulated minimum collateral
    uint expectedLimit = 4 ether; // Expected withdrawal limit based on correct parameters
    assertGt(withdrawalLimit, expectedLimit, "Withdrawal limit exceeds expected due to manipulated minimum collateral"); // Asserting that the withdrawal limit is greater than expected
}

function testOraclePriceManipulation() public { // Function to test oracle price manipulation
    address user = address(1); // Mock user address
    // Manipulate the oracle price to an extremely low value
    MockOracle(address(market.oracle())).setPrice(address(market.collateral()), 0.001 ether); // Setting the price of collateral to an extremely low value
    uint withdrawalLimit = market.getWithdrawalLimitInternal(user); // Recalculating the withdrawal limit for the user
    uint expectedMinimumCollateral = 5000 ether; // Expected minimum collateral based on manipulated parameters
    assertLt(withdrawalLimit, expectedMinimumCollateral, "Oracle manipulation allows excessive withdrawal"); // Asserting that the withdrawal limit is less than expected
}

function testCollateralFactorManipulation() public { // Function to test collateral factor manipulation
    address user = address(1); // Mock user address
    address _gov = address(0x1); // Mock governance address

    // Calculate a withdrawal limit before changing the collateral factor
    uint initialWithdrawalLimit = market.getWithdrawalLimitInternal(user);

    // Impersonate the governance address using vm.startPrank
    vm.startPrank(_gov);
    market.setCollateralFactorBps(100); // Setting the collateral factor to 1%
    vm.stopPrank();

    // Recalculate the withdrawal limit with the adjusted collateral factor
    uint newWithdrawalLimit = market.getWithdrawalLimitInternal(user);

    // Ensure that the withdrawal limit has changed
    assertLt(newWithdrawalLimit, initialWithdrawalLimit, "Collateral factor manipulation fails to affect withdrawal limit"); 
}

function testDebtRepayment() public {
    address user = address(1); 

    // Get initial withdrawal limit
    uint initialWithdrawalLimit = market.getWithdrawalLimitInternal(user);

    // Repay portion of the debt
    market.repay(user, 2 ether); 

    // Get new withdrawal limit
    uint newWithdrawalLimit = market.getWithdrawalLimitInternal(user);

    // Assert that the withdrawal limit has increased due to debt reduction
    assertGt(newWithdrawalLimit, initialWithdrawalLimit, "Debt repayment does not affect withdrawal limit");         
}

function testLiquidation() public {
    address user = address(1);
    address liquidator = address(2); 

    // Manipulate oracle or collateral factor so the user's position is underwater

    // Get initial debt
    uint initialDebt = market.debts(user);

    // Trigger liquidation (you might need to provide some DOLA to the liquidator)
    market.liquidate(user, liquidator); 

    // Get debt after liquidation
    uint remainingDebt = market.debts(user);

    // Assert that the debt has been reduced or cleared
    assertLt(remainingDebt, initialDebt, "Liquidation does not reduce debt"); 
}
}